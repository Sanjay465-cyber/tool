# -*- coding: utf-8 -*-
"""
JeevanSutra Secure Planner — Shared Vault edition

This file is a secure, practical rewrite of the original script with these additions:
 - AES-GCM encryption (scrypt-derived key)
 - Ed25519 signing for integrity
 - Per-person save/load/plan functions
 - **Shared vault** (consent-based) so *others' future plans* can be contributed and
   aggregated to compute *your* present tasks (so your present is optimized using
   other people's future commitments)
 - CLI: save, load, play-views, plan, vault-create, vault-contribute, vault-compute-for, verify

Ethics & safety: contributions require consent and signature. Do not access others' data
without consent.
"""

import os, json, base64, hashlib, time, sys, datetime, random
from dataclasses import dataclass
from typing import List, Dict, Any
import argparse

from cryptography.hazmat.primitives.kdf.scrypt import Scrypt
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import ed25519

# ---------------------- Folders & constants ----------------------
SAVE_FOLDER = "जीवनसूत्र_संग्रह"
KEYS_FOLDER = os.path.join(SAVE_FOLDER, "keys")
os.makedirs(SAVE_FOLDER, exist_ok=True)
os.makedirs(KEYS_FOLDER, exist_ok=True)

IST = datetime.timezone(datetime.timedelta(hours=5, minutes=30), name="Asia/Kolkata")

# ---------------------- Jeevansutra Codes ----------------------
jeevansutra: Dict[str, str] = {
    "G72": "ग्रह", "D66": "देवता", "K48": "कर्म", "T168": "काल",
    "B24": "ब्रह्म", "PB12": "परब्रह्म", "MM": "महामौन", "TUR": "तुरियतित",
    "ANT": "अनुत्तर", "ANTT": "अनन्तातीत", "ATT": "अतीतानुत्तर", "ANIRDESH": "अनिर्देश्यम्",
    "ANIVED": "अनिवेद्यम्", "APRAV": "अप्रवेश्य", "ANUPL": "अनुपलब्ध", "ASVAB": "अस्वभाव्य",
    "AJAT": "अजातम्", "ALAK": "अलक्षणम्", "ALAKSH": "अलक्ष्य", "ACHI": "अचिह्न",
    "ASANG": "असङ्ग", "PAEK": "परमैकत्व", "NIRUP": "निरुपाधि शान्ति", "APRINV": "अपरिनिर्वचनीय",
    "ANADI": "अनादि-अनंत", "PARAN": "परानुभव", "SATY": "सत्य-सत्य", "PAG": "परम-अज्ञेय",
    "APARINAM": "अपरिणाम", "APARINI": "अपरिणीय", "APARIBH": "अपरिभाष्य", "NIRUPDH": "निरूपधि",
    "ADWPAR": "अद्वयात्मक परम-अतिपरम", "PHADPAR": "परमहद्-परम-अनुत्तर",
    "ANTAPR": "अंतिम अपरिव्याप्त", "SACHA": "सर्वोच्च-अकथनीय-अनुत्तर", "ANTPAR": "अंतिम परम",
    "ANIPAS": "अनिर्वचनीय, अपरिमेय, अनुत्तर, शून्य से भी परे",
    "PMAP": "परमहद्-अतिपरम-अनुत्तर", "ULTPAR": "अंतिम अंतिम परम / अनुत्तरातीत परम"
}

# ---------------------- Time Views ----------------------
time_views: List[str] = [
    "Linear Time", "Absolute forward", "Absolute backward", "Accelerated forward", "Accelerated backward",
    "Slow forward", "Slow backward", "Paused/Still", "Interrupted", "Skipped", "Reversed", "Fast-forwarded",
    "Rewound", "Linear memory-based", "Linear predictive", "Linear corrective",
    "Daily cycle", "Weekly cycle", "Monthly cycle", "Yearly cycle", "Seasonal cycle", "Lunar cycle", "Solar cycle",
    "Eternal recurrence", "Karma cycle", "Cosmic cycle", "Mini-cycle", "Macro-cycle", "Nested cycles",
    "Overlapping cycles", "Repeating loop", "Multiverse split", "Alternative path", "Parallel existence",
    "Divergent possibility", "Probabilistic time", "Quantum branch", "Multiple outcomes", "Conditional loop",
    "Hypothetical future", "Hypothetical past", "Variant memory", "Forked timeline", "Collapsing branches",
    "Converging paths", "Parallel observer", "Personal slow", "Personal fast", "Collective slow", "Collective fast",
    "Emotional time", "Consciousness time", "Subconscious time", "Dream-time", "Meditation time", "Mindful presence",
    "Nostalgic past", "Anticipatory future", "Remembrance", "Projection", "Perceived eternal", "3D timeline",
    "4D spacetime", "Cross-dimensional", "Higher-dimensional", "Layered time", "Curved timeline", "Folded time",
    "Entangled time", "Spatialized memory", "Time as space", "Time as loop", "Temporal echo", "Time dilation",
    "Time contraction", "Time compression", "Healing time", "Aging time", "Decay", "Growth", "Evolutionary",
    "Transformative", "Regenerative", "Regressive", "Purifying", "Accelerated learning", "Memory reset",
    "Karma resolution", "Destiny unfolding", "Spiritual awakening", "Enlightenment time", "Illusion of past",
    "Illusion of future", "False continuity", "Fragmented perception", "Time loops in mind", "Dream replay",
    "False anticipation", "False memory", "Mind time warp", "Psychological distortion", "Hallucinated time",
    "Recalled time", "Imaginative time", "Symbolic time", "Archetypal time", "Planetary alignment", "Stellar rotation",
    "Galactic cycle", "Black hole time", "Cosmic expansion", "Universal age", "Entropy-based", "Singularity",
    "Big Bang backward", "Big Crunch forward", "Multiverse oscillation", "Eternal now", "Cosmic loop",
    "Time relativity", "Temporal horizon", "Triggered event", "Conditional loop", "Reward time", "Punishment time",
    "Reactive time", "Action-based time", "Observation-based time", "Threshold time", "Milestone markers",
    "Quantum event timing", "Decision-based", "Contingent future", "Event echo", "Feedback time", "Outcome-dependent",
    "Karma retro", "Dharma forward", "Bhakti time", "Moksha timeless", "Nirvana state", "Cosmic consciousness",
    "Devotional eternity", "Pranic time", "Chakra-aligned time", "Energy vibration", "Sacred ritual time",
    "Astral projection", "Time dilation in meditation", "Divine perspective", "Akasha record", "Eternity beyond mind",
    "Timeless witnessing", "Satvik awareness", "Rajsik flow", "Ultimate union of all times"
]

# ---------------------- Utilities ----------------------

def utc_now_iso() -> str:
    return datetime.datetime.now(datetime.timezone.utc).isoformat()

def ist_now_iso() -> str:
    return datetime.datetime.now(IST).isoformat()

# Key derivation (password -> key)

def derive_key(password: str, salt: bytes) -> bytes:
    kdf = Scrypt(salt=salt, length=32, n=2**14, r=8, p=1)
    return kdf.derive(password.encode("utf-8"))

# Symmetric encryption AES-GCM

def encrypt_json(data: Dict[str, Any], password: str) -> Dict[str, str]:
    plaintext = json.dumps(data, ensure_ascii=False, separators=(",", ":")).encode("utf-8")
    salt = os.urandom(16)
    key = derive_key(password, salt)
    aes = AESGCM(key)
    nonce = os.urandom(12)
    ciphertext = aes.encrypt(nonce, plaintext, None)
    return {
        "salt": base64.b64encode(salt).decode(),
        "nonce": base64.b64encode(nonce).decode(),
        "ciphertext": base64.b64encode(ciphertext).decode(),
    }

def decrypt_json(container: Dict[str, str], password: str) -> Dict[str, Any]:
    salt = base64.b64decode(container["salt"])
    nonce = base64.b64decode(container["nonce"])
    ciphertext = base64.b64decode(container["ciphertext"])
    key = derive_key(password, salt)
    aes = AESGCM(key)
    plaintext = aes.decrypt(nonce, ciphertext, None)
    return json.loads(plaintext.decode("utf-8"))

# ---------------------- Signing (Ed25519) ----------------------
PRIV_PATH = os.path.join(KEYS_FOLDER, "ed25519_private_key.pem")
PUB_PATH = os.path.join(KEYS_FOLDER, "ed25519_public_key.pem")


def ensure_keys() -> ed25519.Ed25519PrivateKey:
    if os.path.exists(PRIV_PATH) and os.path.exists(PUB_PATH):
        with open(PRIV_PATH, "rb") as f:
            private_key = serialization.load_pem_private_key(f.read(), password=None)
        return private_key
    private_key = ed25519.Ed25519PrivateKey.generate()
    public_key = private_key.public_key()
    with open(PRIV_PATH, "wb") as f:
        f.write(
            private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption(),
            )
        )
    with open(PUB_PATH, "wb") as f:
        f.write(
            public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo,
            )
        )
    return private_key


def load_public_key():
    with open(PUB_PATH, "rb") as f:
        return serialization.load_pem_public_key(f.read())


def sign_text(payload_str: str) -> str:
    private_key = ensure_keys()
    sig = private_key.sign(payload_str.encode("utf-8"))
    return base64.b64encode(sig).decode()


def verify_text(payload_str: str, signature_b64: str) -> bool:
    public_key = load_public_key()
    try:
        public_key.verify(base64.b64decode(signature_b64), payload_str.encode("utf-8"))
        return True
    except Exception:
        return False

# ---------------------- Core Save/Load ----------------------

def save_person_jeevansutra(person_name: str, selected_levels: List[str], password: str, deadline_seconds: int = 0):
    data = {
        "levels": {code: jeevansutra.get(code, "Unknown") for code in selected_levels},
        "timestamp_utc": utc_now_iso(),
        "timestamp_ist": ist_now_iso(),
    }
    if deadline_seconds > 0:
        data["deadline_seconds"] = deadline_seconds

    enc = encrypt_json(data, password)
    payload = json.dumps(enc, separators=(",", ":"))
    signature = sign_text(payload)

    file_path = os.path.join(SAVE_FOLDER, f"{person_name}.json")
    with open(file_path, "w", encoding="utf-8") as f:
        json.dump({"encrypted": enc, "signature": signature}, f, ensure_ascii=False, indent=2)

    print(f"✅ {person_name} का encrypted जीवनसूत्र सुरक्षित: {file_path}")


def load_person_jeevansutra(person_name: str, password: str) -> Dict[str, Any]:
    file_path = os.path.join(SAVE_FOLDER, f"{person_name}.json")
    with open(file_path, "r", encoding="utf-8") as f:
        container = json.load(f)

    enc = container["encrypted"]
    signature = container["signature"]
    payload = json.dumps(enc, separators=(",", ":"))
    if not verify_text(payload, signature):
        raise ValueError("❌ Signature invalid! Data may be tampered.")
    decoded = decrypt_json(enc, password)
    # enforce deadline
    if "deadline_seconds" in decoded:
        saved_dt = datetime.datetime.fromisoformat(decoded["timestamp_utc"])
        expires = saved_dt.timestamp() + decoded["deadline_seconds"]
        if time.time() > expires:
            raise TimeoutError("⏳ Deadline passed — access locked!")
    return decoded

# ---------------------- Time-View Player ----------------------

def समय_दृष्टि_play(n: int = 5):
    n = max(1, min(n, len(time_views)))
    selected = random.sample(time_views, n)
    print("
--- समय-दृष्टि अनुभव ---")
    for i, view in enumerate(selected, 1):
        print(f"{i}. {view}")
    print("----------------------
")

# ---------------------- Future → Present Planner ----------------------
@dataclass
class Goal:
    title: str
    why: str
    deadline: str
    dependency_on: str = ""  # optional: name of a deliverable from someone else


def plan_today(goals: List[Goal]) -> Dict[str, Any]:
    today = datetime.datetime.now(IST).date()
    scored: List[Dict[str, Any]] = []
    for g in goals:
        try:
            dl = datetime.date.fromisoformat(g.deadline[:10])
        except Exception:
            dl = today
        days_left = max(0, (dl - today).days)
        urgency = 100 - min(100, days_left)
        importance = min(100, 50 + len(g.why) // 4)
        score = 0.6 * importance + 0.4 * urgency
        scored.append({"goal": g, "score": score, "days_left": days_left})
    scored.sort(key=lambda x: x["score"], reverse=True)
    top = scored[:3]
    mits = [
        {"task": f"{t['goal'].title} — next concrete step", "why": t['goal'].why, "timebox": "60 min"}
        for t in top
    ]
    deep_work = ["30 min focus", "60 min focus", "90 min focus"]
    day_after_tomorrow = (today + datetime.timedelta(days=2)).isoformat()
    prep = f"Prepare today for {day_after_tomorrow}: list blockers, gather materials, schedule 1st slot."
    habit = "2-min start ritual: breathe 6x, open planner, start stopwatch, begin first MIT."
    return {"date": today.isoformat(), "MITS": mits, "DeepWork": deep_work, "PrepForDayAfterTomorrow": prep, "MicroHabit": habit}

# ---------------------- Shared Vault (consent-based) ----------------------
# Vault file format: vault__<name>.json -> { encrypted: {salt,nonce,ciphertext}, signature }
# The vault contains participants (consent flag) and contributions per person.


def create_shared_vault(vault_name: str, participants: List[str], group_password: str) -> str:
    vault = {
        "vault_name": vault_name,
        "participants": {p: {"consent": False, "signed": None} for p in participants},
        "contributions": {},
        "created_utc": utc_now_iso(),
    }
    enc = encrypt_json(vault, group_password)
    payload = json.dumps(enc, separators=(",", ":"))
    signature = sign_text(payload)
    path = os.path.join(SAVE_FOLDER, f"vault__{vault_name}.json")
    with open(path, "w", encoding="utf-8") as f:
        json.dump({"encrypted": enc, "signature": signature}, f, ensure_ascii=False, indent=2)
    return path


def contribute_to_vault(vault_name: str, person: str, person_goals: List[Dict[str,Any]], group_password: str, person_password: str) -> bool:
    path = os.path.join(SAVE_FOLDER, f"vault__{vault_name}.json")
    if not os.path.exists(path):
        raise FileNotFoundError("Vault not found")
    with open(path, "r", encoding="utf-8") as f:
        container = json.load(f)
    enc = container["encrypted"]
    if not verify_text(json.dumps(enc, separators=(",", ":")), container["signature"]):
        raise ValueError("Vault signature invalid!")
    vault = decrypt_json(enc, group_password)
    # Verify contributor owns their person file by attempting decrypt with person_password
    person_path = os.path.join(SAVE_FOLDER, f"{person}.json")
    if not os.path.exists(person_path):
        raise FileNotFoundError("Person file not found for consent check")
    with open(person_path, "r", encoding="utf-8") as pf:
        pcontainer = json.load(pf)
    try:
        _ = decrypt_json(pcontainer["encrypted"], person_password)
    except Exception:
        raise ValueError("Contributor authentication failed — bad person_password")
    # Record the contribution with signature (contributor signs their contribution string)
    contribution = {"submitted_at_utc": utc_now_iso(), "goals": person_goals, "signed_by": person}
    contribution_str = json.dumps(contribution, ensure_ascii=False, separators=(",", ":"))
    contribution_sig = sign_text(contribution_str)
    vault.setdefault("contributions", {}).setdefault(person, []).append({"payload": contribution, "sig": contribution_sig})
    vault.setdefault("participants", {}).setdefault(person, {})["consent"] = True
    vault["participants"][person]["signed"] = contribution_sig
    # Re-encrypt and sign vault
    new_enc = encrypt_json(vault, group_password)
    new_payload = json.dumps(new_enc, separators=(",", ":"))
    new_sig = sign_text(new_payload)
    with open(path, "w", encoding="utf-8") as f:
        json.dump({"encrypted": new_enc, "signature": new_sig}, f, ensure_ascii=False, indent=2)
    return True


def compute_present_for_user_from_vault(vault_name: str, target_user: str, group_password: str) -> Dict[str, Any]:
    path = os.path.join(SAVE_FOLDER, f"vault__{vault_name}.json")
    if not os.path.exists(path):
        raise FileNotFoundError("Vault not found")
    with open(path, "r", encoding="utf-8") as f:
        container = json.load(f)
    enc = container["encrypted"]
    vault = decrypt_json(enc, group_password)
    # Aggregate contributions: look for declared dependencies that affect target_user
    aggregated = []
    for person, contribs in vault.get("contributions", {}).items():
        for item in contribs:
            payload = item.get("payload", {})
            for g in payload.get("goals", []):
                aggregated.append({"person": person, "goal": g})
    # Rule engine (simple): if any contributed goal has 'dependency_on' matching an action
    # or keyword in target_user's personal goals, create MITs for target_user.
    # For demo, interpret 'dependency_on' field in contributed goal.
    mits = []
    for entry in aggregated:
        person = entry["person"]
        g = entry["goal"]
        dep = g.get("dependency_on")
        if dep:
            mits.append({
                "task": f"Prepare to act when '{dep}' from {person} completes",
                "reason": f"Because {person} plans '{g.get('title', '')}' which depends on {dep}"
            })
    if not mits:
        mits.append({"task": "Monitor vault; no external dependencies found — continue personal MITs", "reason": "No shared triggers present"})
    return {"date": ist_now_iso(), "MITS": mits, "vault_name": vault.get("vault_name")}

# ---------------------- CLI ----------------------

def build_parser():
    p = argparse.ArgumentParser(description="JeevanSutra Secure Planner — Shared Vault edition")
    sub = p.add_subparsers(dest="cmd", required=True)

    s_save = sub.add_parser("save", help="Encrypt+sign a JeevanSutra file")
    s_save.add_argument("person")
    s_save.add_argument("password")
    s_save.add_argument("levels", nargs="+")
    s_save.add_argument("--deadline", type=int, default=0)

    s_load = sub.add_parser("load", help="Decrypt+verify a JeevanSutra file")
    s_load.add_argument("person")
    s_load.add_argument("password")

    s_tv = sub.add_parser("play-views", help="Play random time-views")
    s_tv.add_argument("--n", type=int, default=10)

    s_plan = sub.add_parser("plan", help="Turn goals into today's best-present plan")
    s_plan.add_argument("goals_json")

    s_vc = sub.add_parser("vault-create", help="Create a shared vault")
    s_vc.add_argument("vault_name")
    s_vc.add_argument("participants", nargs="+")
    s_vc.add_argument("group_password")

    s_vcont = sub.add_parser("vault-contribute", help="Contribute to a shared vault (requires your person file and password)")
    s_vcont.add_argument("vault_name")
    s_vcont.add_argument("person")
    s_vcont.add_argument("person_password")
    s_vcont.add_argument("group_password")
    s_vcont.add_argument("goals_json")

    s_vcomp = sub.add_parser("vault-compute-for", help="Compute present MITs for a user based on vault")
    s_vcomp.add_argument("vault_name")
    s_vcomp.add_argument("target_user")
    s_vcomp.add_argument("group_password")

    s_verify = sub.add_parser("verify", help="Verify signature of a person file")
    s_verify.add_argument("person")

    return p


def cmd_save(args):
    ensure_keys()
    save_person_jeevansutra(args.person, args.levels, args.password, args.deadline)


def cmd_load(args):
    obj = load_person_jeevansutra(args.person, args.password)
    print("
✅ Decoded जीवनसूत्र:")
    for code, name in obj["levels"].items():
        print(f"{code} → {name}")
    print(f"UTC: {obj['timestamp_utc']}")
    print(f"IST: {obj['timestamp_ist']}")


def cmd_play_views(args):
    समय_दृष्टि_play(args.n)


def cmd_plan(args):
    with open(args.goals_json, "r", encoding="utf-8") as f:
        raw = json.load(f)
    goals = [Goal(**g) for g in raw]
    plan = plan_today(goals)
    print(json.dumps(plan, ensure_ascii=False, indent=2))


def cmd_vault_create(args):
    path = create_shared_vault(args.vault_name, args.participants, args.group_password)
    print(f"✅ Vault created: {path}")


def cmd_vault_contribute(args):
    with open(args.goals_json, "r", encoding="utf-8") as f:
        goals = json.load(f)
    success = contribute_to_vault(args.vault_name, args.person, goals, args.group_password, args.person_password)
    if success:
        print("✅ Contribution saved to vault")


def cmd_vault_compute(args):
    out = compute_present_for_user_from_vault(args.vault_name, args.target_user, args.group_password)
    print(json.dumps(out, ensure_ascii=False, indent=2))


def cmd_verify(args):
    path = os.path.join(SAVE_FOLDER, f"{args.person}.json")
    with open(path, "r", encoding="utf-8") as f:
        container = json.load(f)
    enc = container["encrypted"]
    sig = container["signature"]
    ok = verify_text(json.dumps(enc, separators=(",", ":")), sig)
    print("Signature:", "✅ valid" if ok else "❌ invalid")


if __name__ == "__main__":
    parser = build_parser()
    a = parser.parse_args()
    if a.cmd == "save":
        cmd_save(a)
    elif a.cmd == "load":
        cmd_load(a)
    elif a.cmd == "play-views":
        cmd_play_views(a)
    elif a.cmd == "plan":
        cmd_plan(a)
    elif a.cmd == "vault-create":
        cmd_vault_create(a)
    elif a.cmd == "vault-contribute":
        cmd_vault_contribute(a)
    elif a.cmd == "vault-compute-for":
        cmd_vault_compute(a)
    elif a.cmd == "verify":
        cmd_verify(a)
